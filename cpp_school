#include <iostream>
#include <limits>
#include <fstream>
#include <string>
#include <sstream>
#include <cstring>
#include <stdlib.h>

using namespace std;

// Linked list node structure
typedef struct Node
{
    int process;             // Process ID
    int arrival_time;        // Arrival time of the process
    int burst_time;          // Burst time of the process
    int priority;            // Priority of the process
    int turnaround_time;     // Turnaround time of the process
    int waiting_time;        // Waiting time of the process
    int time_remaining;      // Remaining time for the process (used in Round Robin)
    float average_time;      // Average time (not used)
    struct Node *next;       // Pointer to the next node in the linked list
} NODE;

NODE *head, *tail = NULL;  // Head and tail pointers for the linked list
// Validator for input options
int Validator(int option, int startLimit, int endLimit)
{
    if ((option <= startLimit || option <= endLimit) && (option != 0))
    {
        return true;
    }
    else
    {
        // Clear input buffer and ignore invalid input
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return false;
    }
}

// Validator for time inputs
int timeValidator(int time)
{
    if (time == 0)
    {
        // Clear input buffer and ignore invalid time
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return false;
    }
    else
    {
        return true;
    }
}

// Function to sort the linked list based on different criteria
void sortHandler(int method)
{

    NODE *current = head, *index = NULL;

    int temp, burst, prior;

    if (head == NULL)
    {
        return;
    }
    else
    {
        while (current != NULL)
        {
            index = current->next;

            while (index != NULL)
            {
                if (method == 1) // Sort list according to arrival time
                {
                    if (current->arrival_time > index->arrival_time)
                    {
                        // Swap arrival time, burst time, and priority
                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;

                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;
                    }
                }
                else if (method == 2) // Sort list according to burst time
                {
                    if (current->burst_time > index->burst_time)
                    {
                        // Swap burst time, arrival time, and priority
                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;

                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;
                    }
                }
                else if (method == 3) //sort list according to priority
                {
                    if (current->priority > index->priority)
                    {
                        // Swap priority, burst time, and arrival time
                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;

                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;
                    }
                }

                index = index->next;
            }
            current = current->next;
        }
    }
}