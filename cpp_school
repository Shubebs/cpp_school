#include <iostream>
#include <limits>
#include <fstream>
#include <string>
#include <sstream>
#include <cstring>
#include <stdlib.h>

using namespace std;

// Linked list node structure
typedef struct Node
{
    int process;             // Process ID
    int arrival_time;        // Arrival time of the process
    int burst_time;          // Burst time of the process
    int priority;            // Priority of the process
    int turnaround_time;     // Turnaround time of the process
    int waiting_time;        // Waiting time of the process
    int time_remaining;      // Remaining time for the process (used in Round Robin)
    float average_time;      // Average time (not used)
    struct Node *next;       // Pointer to the next node in the linked list
} NODE;

NODE *head, *tail = NULL;  // Head and tail pointers for the linked list
// Validator for input options
int Validator(int option, int startLimit, int endLimit)
{
    if ((option <= startLimit || option <= endLimit) && (option != 0))
    {
        return true;
    }
    else
    {
        // Clear input buffer and ignore invalid input
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return false;
    }
}

// Validator for time inputs
int timeValidator(int time)
{
    if (time == 0)
    {
        // Clear input buffer and ignore invalid time
        cin.clear();
        cin.ignore(numeric_limits<streamsize>::max(), '\n');
        return false;
    }
    else
    {
        return true;
    }
}

// Function to sort the linked list based on different criteria
void sortHandler(int method)
{

    NODE *current = head, *index = NULL;

    int temp, burst, prior;

    if (head == NULL)
    {
        return;
    }
    else
    {
        while (current != NULL)
        {
            index = current->next;

            while (index != NULL)
            {
                if (method == 1) // Sort list according to arrival time
                {
                    if (current->arrival_time > index->arrival_time)
                    {
                        // Swap arrival time, burst time, and priority
                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;

                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;
                    }
                }
                else if (method == 2) // Sort list according to burst time
                {
                    if (current->burst_time > index->burst_time)
                    {
                        // Swap burst time, arrival time, and priority
                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;

                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;
                    }
                }
                else if (method == 3) //sort list according to priority
                {
                    if (current->priority > index->priority)
                    {
                        // Swap priority, burst time, and arrival time
                        prior = current->priority;
                        current->priority = index->priority;
                        index->priority = prior;

                        burst = current->burst_time;
                        current->burst_time = index->burst_time;
                        index->burst_time = burst;

                        temp = current->arrival_time;
                        current->arrival_time = index->arrival_time;
                        index->arrival_time = temp;
                    }
                }

                index = index->next;
            }
            current = current->next;
        }
    }
}

// Function to control Round Robin Scheduling
void RRScontroller(NODE *head, int time_quantum, int count, string file)
{

    float total = 0;
    ofstream myfile;
    myfile.open(file.c_str(), ios_base::app);

    // Round Robin scheduling linked list
    sortHandler(1);

    head->waiting_time = 0;

    int current_time = 0;
    int i = 0;
    myfile << "\nScheduling Method: Robin Round Scheduling Method" << endl;
    myfile << "Process Waiting Times :\n"
           << endl;
    do
    {
        bool counter = true;

        while (head != NULL)
        {
            if (head->time_remaining > 0)
            {
                counter = false;

                if (head->time_remaining > time_quantum)
                {
                    current_time = current_time + time_quantum;

                    head->time_remaining -= time_quantum;
                }
                else
                {
                    current_time = current_time + head->time_remaining;

                    head->waiting_time = current_time - head->burst_time;

                    head->time_remaining = 0;
                }
            }
            total += head->waiting_time;
            i++;
            myfile << "P" << i << " : " << head->waiting_time << endl;
            head = head->next;
        }
        if (counter == true)
            break;
    } while (true);

    myfile << "\nAverage Waiting Time: " << total / count << endl;
    myfile.close();
}